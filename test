'use strict';

// load configuration
var config = require('./config.json');

console.log(config);

// logger
var bunyan = require('bunyan');

// node utils
var util = require('util');

// SDK logger
var sdkLogger = bunyan.createLogger({
    name: 'sdk',
    stream: process.stdout,
    level: config.sdkLogLevel
});

// Application logger
var logger = bunyan.createLogger({
    name: 'app',
    stream: process.stdout,
    level: 'debug'
});

// Circuit SDK
logger.info('[CIRCUIT]: get Circuit instance');
var Circuit = require('circuit-sdk');

logger.info('[CIRCUIT]: Circuit set bunyan logger');
Circuit.setLogger(sdkLogger);


//Imap
var imaps = require('imap-simple');

//*********************************************************************
//* Circuit-Adapter
//*********************************************************************
var fCircuit = function () {

    var self = this;
    var client = null;

    //*********************************************************************
    //* Circuit - logonBot
    //*********************************************************************
    this.logon = function logon() {
        logger.info('[CIRCUIT]: logon');
        return new Promise(function (resolve, reject) {
            logger.info('[CIRCUIT]: createClient');
            client = new Circuit.Client({
                client_id: config.client_id,
                client_secret: config.client_secret,
                domain: config.domain,
                autoRenewToken: true
            });
            self.addEventListeners(client); //register evt listeners
            client.logon()
                .then(function loggedOn(user) {
                    logger.info('[CIRCUIT]: loggedOn', user);
                    return client.setPresence({state: Circuit.Enums.PresenceState.AVAILABLE});
                })
                .then(user => {
                    console.log('Presence updated', user);
                    resolve();
                })
                .catch(reject);
        });
    };

    //*********************************************************************
    //* Circuit - addEventListeners
    //*********************************************************************
    this.addEventListeners = function addEventListeners(client) {
        logger.info('[CIRCUIT]: addEventListeners');
        //set event callbacks for this client
        client.addEventListener('connectionStateChanged', function (evt) {
            self.logEvent(evt);
        });
        client.addEventListener('registrationStateChanged', function (evt) {
            self.logEvent(evt);
        });
        client.addEventListener('reconnectFailed', function (evt) {
            self.logEvent(evt);
        });
        client.addEventListener('itemAdded', function (evt) {
            self.logEvent(evt);
        });
        client.addEventListener('itemUpdated', function (evt) {
            self.logEvent(evt);
        });
    };

    //*********************************************************************
    //* Circuit - logEvent -- helper
    //*********************************************************************
    this.logEvent = function logEvent(evt) {
        logger.info('[CIRCUIT]:', evt.type, 'event received');
        logger.debug('[CIRCUIT]:', util.inspect(evt, { showHidden: true, depth: null }));
    };

    //*********************************************************************
    //* Circuit - Post Message
    //*********************************************************************
    this.postMessage = async function (content, subject, conversationID) {
        logger.info('[CIRCUIT]: SEND MESSAGE: ', content, subject, conversationID);
        var message = {
            content: content,
            subject: subject
        };
        return client.addTextItem(conversationID, message);
    };
};

//*********************************************************************
//* run
//*********************************************************************
function run() {

  var imapconfig = {
    imap: {
      user: config.imap_user,
      password: config.imap_password,
      host: config.imap_host,
      port: config.imap_port,
      tls: config.imap_tls,
      authTimeout: 3000
    },
    onmail: function (numNewMail) {
      logger.info('[IMAP]: NEW MAIL RECEIVED');

      var fetchconfig = {
        imap: {
          user: config.imap_user,
          password: config.imap_password,
          host: config.imap_host,
          port: config.imap_port,
          tls: config.imap_tls,
          authTimeout: 3000
        }
      }

      imaps.connect(fetchconfig).then(function (fetchconnection) {

        return fetchconnection.openBox('INBOX').then(function () {
          var searchCriteria = [
             'UNSEEN'
          ];
    
          var fetchOptions = {
             bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)', 'TEXT'],
             markSeen: true,
             struct: true
         };
    
         return fetchconnection.search(searchCriteria, fetchOptions).then(function (messages) {
          messages.forEach(function (message) {
            var parts = imaps.getParts(message.attributes.struct);
            
            console.log(parts);

            var subject = `Subject: ${subjects}`;
            var content = `Content: ${contents}`;
            var conversationID = '0dedc2ce-733f-4fcc-a7dd-60d3b1e0a1c1';
            circuit.postMessage(content, subject, conversationID);
         });

         return fetchconnection.end();
        });
      });
    });
  };
 
  
  imaps.connect(imapconfig).then(function (connection) {

    return connection.openBox('INBOX').then(function () {
      var searchCriteria = [
        'UNSEEN'
     ];

     var fetchOptions = {
        bodies: ['HEADER', 'TEXT'],
        markSeen: true
    };
    });

  }); 

  var circuit = new fCircuit();

    circuit.logon()
        .catch(function (e) {
            logger.error('[CIRCUIT]:', e);
        })
    ; 
}

//******************************************************************
//* main
//*********************************************************************
run();



            
            return res.parts.filter(function (part) {
              return part.which === 'HEADER';
            });



        messages.forEach(function (message) {
            var parts = imaps.getParts(message.attributes.struct); 
            header_from = header_from.concat(parts.filter(function (part) {
              return part.disposition && part.disposition.type.toUpperCase() === 'FROM';
            header_to = header_to.concat(parts.filter(function (part) {
              return part.disposition && part.disposition.type.toUpperCase() === 'TO';
            header_subject = header_subject.concat(parts.filter(function (part) {
              return part.disposition && part.disposition.type.toUpperCase() === 'SUBJECT';            
          }));

            console.log('header_from:');
            console.log(header_from);
            console.log('header_to:');
            console.log(header_to);
            console.log('header_subject:');
            console.log(header_subject);

            var subject = `Subject: ${subjects}`;
            var content = `Content: ${contents}`;
            var conversationID = '0dedc2ce-733f-4fcc-a7dd-60d3b1e0a1c1';
            circuit.postMessage(content, subject, conversationID);
         }));